diff --git a/README b/README
index 26d5ad273e..15542b816d 100644
--- a/README
+++ b/README
@@ -5,6 +5,15 @@
 # SPDX-License-Identifier:	GPL-2.0+
 #
 
+TMR Instructions:
+=================
+
+The TMR code is written in common/tmr.c and implemented in common/main.c (n main_loop()).
+
+Before flashing, some modifications must be made on the TX2i filesystem. Make 3 copies of the boot image (stored as /boot/Image, /boot/Image1, /boot/Image2), and store an md5 hash for each (/boot/hash, /boot/hash1, /boot/hash2). The filesize of the image is hard-coded into the TMR code (0x34048008 bytes, in hex), and this should be changed on common/tmr.c:68 if using an image of a different size.
+
+To flash the kernel, follow the "U-Boot Customization" instructions in the L4T docs, particularly the "Flashing U-Boot Only" section.
+
 Summary:
 ========
 
diff --git a/cmd/md5sum.c b/cmd/md5sum.c
index 23bb81e88c..e653b80deb 100644
--- a/cmd/md5sum.c
+++ b/cmd/md5sum.c
@@ -13,6 +13,7 @@
 #include <mapmem.h>
 #include <u-boot/md5.h>
 #include <asm/io.h>
+#include "../lib/md5.c"
 
 /*
  * Store the resulting sum to an address or variable
diff --git a/common/autoboot.c b/common/autoboot.c
index c52bad84a4..1c61866935 100644
--- a/common/autoboot.c
+++ b/common/autoboot.c
@@ -255,7 +255,7 @@ static int __abortboot(int bootdelay)
 }
 # endif	/* CONFIG_AUTOBOOT_KEYED */
 
-static int abortboot(int bootdelay)
+int abortboot(int bootdelay)
 {
 	int abort = 0;
 
diff --git a/common/main.c b/common/main.c
index 2116a9e0a2..0e5001074c 100644
--- a/common/main.c
+++ b/common/main.c
@@ -11,7 +11,10 @@
 #include <autoboot.h>
 #include <cli.h>
 #include <console.h>
+#include <malloc.h>
 #include <version.h>
+#include <../common/tmr.c>
+#include <command.h>
 
 DECLARE_GLOBAL_DATA_PTR;
 
@@ -63,6 +66,123 @@ void main_loop(void)
 	if (cli_process_fdt(&s))
 		cli_secure_boot_cmd(s);
 
+	if(fs_set_blk_dev("mmc", "0:1", FS_TYPE_EXT))
+	{
+		// error: no file system --> Assume BLOB
+		ulong file_offset[8] = {0, 1, 2, 90002, 90003, 92003, 92004, 97004};
+		ulong part_size = 4800000;
+		ulong part_offset[3] = {4104, 4104+part_size, 4104+(2*part_size)};
+		ulong outputs[4] = {0xa5000000, 0xa5001000, 0xa9000000, 0xb0000000};
+		ulong sizes[4];
+		sizes[0] = 60; //info file
+		char *safe = "s=----";
+
+		printf("TMRing info files\n");
+		if(
+			tmr_blob(
+				part_offset[0] + file_offset[0],
+				part_offset[0] + file_offset[1],
+				part_offset[1] + file_offset[0],
+				part_offset[1] + file_offset[1],
+				part_offset[2] + file_offset[0],
+				part_offset[2] + file_offset[1],
+				sizes[0], outputs[0])
+		) {
+			safe[2] = 'x';
+		}
+		
+		printf("Reading info for filesizes\n");
+		char tmp[15];
+		char *info = (char *)map_sysmem(locations[0], 45);
+		for (int i = 0; i < 3; i ++) {
+			memcpy(tmp, info + 15 * i, 15);
+			sizes[i+1] = simple_strtoul(tmp, NULL, 10);
+		}
+		unmap_sysmem((const void*) info);
+
+		for (int i = 1; i < 4; i ++) {
+			printf("TMRing file #%d of size %lu\n", i, sizes[i]);
+			if(
+				!tmr_blob(
+					part_offset[0] + file_offset[2*i],
+					part_offset[0] + file_offset[2*i+1],
+					part_offset[1] + file_offset[2*i],
+					part_offset[1] + file_offset[2*i+1],
+					part_offset[2] + file_offset[2*i],
+					part_offset[2] + file_offset[2*i+1],
+					sizes[i], outputs[i])
+			) {
+				// pass info to kernel
+				safe[i+2] = 'x';
+			}
+		}
+
+		// TODO: See if we can find a way to make use of bootargs
+		//setenv("bootargs", safe);
+		char bootargs[CONFIG_SYS_CBSIZE];
+		cli_simple_process_macros("${cbootargs} root=/dev/ram0 rw rootwait ${bootargs}", bootargs);
+		setenv("bootargs", bootargs);
+
+		if(!abortboot(5)) {
+			char initrd_loc[20] = "b0000000:";
+			char initrd_size[15];
+			initrd_size[14]=0; // null terminate
+			char *p = &initrd_size[13];
+			// create string from filesize of initrd
+			ulong i = sizes[3];
+			ulong tmp;
+			do {
+				tmp = i % 16;
+				if (tmp > 9)
+					tmp += 7; // if greater than '9', go to 'A'
+				*p-- = '0' + tmp;
+				i /= 16;
+			} while (i > 0);
+			// p+1 now points to the beginning of size string
+			char *argv[4] = {"booti", "a5001000", strcat(initrd_loc,p+1), "a9000000"};
+			cmd_tbl_t *bcmd = find_cmd("booti");
+			do_booti(bcmd, 0, 4, argv);
+		} else {
+			cli_loop();
+			panic("No CLI available");
+		}
+
+	} 
+	else
+	{
+		char *tmr_names[6];
+		printf("Reading filenames from info file\n");
+		loff_t actread;
+		fs_read("info", 0x84000000, 0, 600, &actread);
+		printf("Read %lld of 600 bytes\n", actread);
+		char *all_names = (char *)map_sysmem(0x84000000, 600);
+
+		for (int i = 0; i < 6; i ++) {
+			tmr_names[i] = (char *)malloc(100);
+			memcpy(tmr_names[i], all_names+100*i, 100);
+		}
+
+		for(int i = 0; i < 3; i ++){
+			char file1[110] = "/boot/";
+			char file2[110] = "/boot1/";
+			char file3[110] = "/boot2/";
+			char hash[110] = "/boothash/";
+			strcat(file1, tmr_names[2*i]);
+			strcat(file2, tmr_names[2*i]);
+			strcat(file3, tmr_names[2*i]);
+			strcat(hash, tmr_names[2*i]);
+			char * const tmr_files[] = {file1, hash, file2, hash, file3, hash};
+			loff_t tmr_size = (loff_t) simple_strtoul(tmr_names[2*i+1], NULL, 10);
+			printf("Redundancy for %s, %s, %s, %s with size %lld\n", file1, file2, file3, hash, tmr_size);
+			tmr_fs(tmr_files, tmr_size); 
+		}
+
+		unmap_sysmem((const void *)all_names);
+	}
+	
+
+	
+
 	autoboot_command(s);
 
 	cli_loop();
diff --git a/common/tmr.c b/common/tmr.c
new file mode 100644
index 0000000000..a9e3629c0f
--- /dev/null
+++ b/common/tmr.c
@@ -0,0 +1,205 @@
+#include <common.h>
+#include <console.h>
+#include <bootretry.h>
+#include <cli.h>
+#include <command.h>
+#include <console.h>
+#include <mapmem.h>
+#include <watchdog.h>
+#include <fs.h>
+#include <u-boot/md5.h>
+#include <blk.h>
+#include <mmc.h>
+
+loff_t filesize;
+ulong locations[7] = {0x85000000,0x89000000,0x90000000,0x94000000,0x95000000,0x99000000,0xa0000000};
+
+static void load_files_with_hashes(char * const files[]) {
+	for(ulong i = 0; i < 6; i ++) {
+		fs_set_blk_dev("mmc", "0:1", FS_TYPE_EXT);
+		loff_t actread;
+		if(i % 2) {
+			fs_read(files[i], locations[i], 0, 32, &actread);
+			printf("Read %lld of 32 bytes from %s\n", actread, files[i]);
+		} else {
+			fs_read(files[i], locations[i], 0, filesize, &actread);
+			printf("Read %lld of %lld bytes from %s\n", actread, filesize, files[i]);
+		}
+	}
+}
+
+static void load_blobs_with_hashes(
+	ulong file1, ulong hash1, 
+	ulong file2, ulong hash2,
+	ulong file3, ulong hash3
+)
+{
+	struct mmc *mmc;
+	printf("Finding mmc device 0\n");
+	mmc = find_mmc_device(0);
+	mmc->has_init = 0;
+	printf("Initializing mmc device 0\n");
+	mmc_init(mmc);
+
+	u32 cnt = filesize / 512 + 1;
+
+	void *addr = (void *)locations[0];
+	printf("Reading from mmc\n");
+	ulong n = blk_dread(mmc_get_blk_desc(mmc), file1, cnt, addr);
+	printf("Flushing cache\n");
+	flush_cache((ulong)addr, cnt * 512);
+	printf("%lu blocks read: %s\n", n, (n == cnt) ? "OK" : "ERROR");
+
+	addr = (void *)locations[1];
+	n = blk_dread(mmc_get_blk_desc(mmc), hash1, 1, addr);
+	flush_cache((ulong)addr, 512);
+	printf("%lu blocks read: %s\n", n, (n == 1) ? "OK" : "ERROR");
+
+	addr = (void *)locations[2];
+	n = blk_dread(mmc_get_blk_desc(mmc), file2, cnt, addr);
+	flush_cache((ulong)addr, cnt * 512);
+	printf("%lu blocks read: %s\n", n, (n == cnt) ? "OK" : "ERROR");
+
+	addr = (void *)locations[3];
+	n = blk_dread(mmc_get_blk_desc(mmc), hash2, 1, addr);
+	flush_cache((ulong)addr, 512);
+	printf("%lu blocks read: %s\n", n, (n == 1) ? "OK" : "ERROR");
+
+	addr = (void *)locations[4];
+	n = blk_dread(mmc_get_blk_desc(mmc), file3, cnt, addr);
+	flush_cache((ulong)addr, cnt * 512);
+	printf("%lu blocks read: %s\n", n, (n == cnt) ? "OK" : "ERROR");
+
+	addr = (void *)locations[5];
+	n = blk_dread(mmc_get_blk_desc(mmc), hash3, 1, addr);
+	flush_cache((ulong)addr, 512);
+	printf("%lu blocks read: %s\n", n, (n == 1) ? "OK" : "ERROR");
+}
+
+int check_hash(int file) {
+	unsigned char calculated_sum[16], tmp[2];
+	
+	void *buf = map_sysmem(locations[file*2], filesize);
+	md5_wd(buf, filesize, calculated_sum, 64 << 10);
+	unmap_sysmem(buf);
+
+	buf = map_sysmem(locations[file*2+1], 32);
+
+	for (int i = 0; i < 16; i++) {
+		memcpy(tmp, (u8 *)buf + 2*i, 2);
+		if(simple_strtoul(tmp, NULL, 16) != calculated_sum[i]) {
+			unmap_sysmem(buf);
+			return 0;
+		}
+	}
+
+	unmap_sysmem(buf);
+	return 1;
+}
+
+static int majority_wd(ulong addr1, ulong addr2, ulong addr3, ulong dest, ulong bytes) {
+
+	ulong	nread;
+	void *buf1, *buf2, *buf3, *buf4;
+
+	ulong word1, word2, word3, word4;
+
+	buf1 = map_sysmem(addr1, bytes);
+	buf2 = map_sysmem(addr2, bytes);
+	buf3 = map_sysmem(addr3, bytes);
+	buf4 = map_sysmem(dest, bytes);
+
+	for (nread = 0; nread < bytes; nread ++) {
+
+		word1 = *(u8 *)buf1;
+		word2 = *(u8 *)buf2;
+		word3 = *(u8 *)buf3;
+
+		word4 = (word1 & word2) | (word2 & word3) | (word3 & word1); //majority voting gate
+
+		*(u8 *)buf4 = word4;
+
+		buf1 += 1;
+		buf2 += 1;
+		buf3 += 1;
+		buf4 += 1;
+
+		/* reset watchdog from time to time */
+		if ((nread % (64 << 10)) == 0)
+			WATCHDOG_RESET();
+
+	}
+
+	unmap_sysmem(buf1);
+	unmap_sysmem(buf2);
+	unmap_sysmem(buf3);
+	unmap_sysmem(buf4);
+
+	return 0;
+
+}
+
+static void tmr_fs(char * const files[], loff_t size) {
+	filesize = size;
+	load_files_with_hashes(files);
+	loff_t actwrite;
+	printf("loaded files with hashes\n");
+	if (check_hash(0)) {
+		printf("hash for original file was correct\n");
+		return;
+	} else if (check_hash(1)) {
+		fs_set_blk_dev("mmc", "0:1", FS_TYPE_EXT);
+		printf("hash for first backup was correct\n");
+		fs_write(files[0], locations[2], 0, filesize, &actwrite);
+		return;
+	} else if (check_hash(2)) {
+		fs_set_blk_dev("mmc", "0:1", FS_TYPE_EXT);
+		printf("hash for second backup was correct\n");
+		fs_write(files[0], locations[4], 0, filesize, &actwrite);
+		return;
+	}
+
+	printf("none of the hashes were correct. storing tmr result at 0xa0000000\n");
+
+	majority_wd(locations[0], locations[2], locations[4], locations[6], filesize);
+	fs_set_blk_dev("mmc", "0:1", FS_TYPE_EXT);
+	fs_write(files[0], locations[6], 0, filesize, &actwrite);
+	printf("Wrote tmr result with size %lld of %lld back to %s\n", actwrite, filesize, files[0]);
+}
+
+static void write_output(ulong input, ulong output) {
+	memcpy((void *)output, (void *)input, filesize);
+}
+
+static bool tmr_blob(
+	ulong file1, ulong hash1, 
+	ulong file2, ulong hash2,
+	ulong file3, ulong hash3,
+	ulong bytes, ulong output)
+{
+	filesize = bytes;
+	
+	load_blobs_with_hashes(file1, hash1, file2, hash2, file3, hash3);
+	printf("loaded files with hashes\n");
+	if (check_hash(0)) {
+		printf("hash for original file was correct\n");
+		write_output(locations[0], output);
+		return true;
+	} else if (check_hash(1)) {
+		fs_set_blk_dev("mmc", "0:1", FS_TYPE_EXT);
+		printf("hash for first backup was correct\n");
+		write_output(locations[2], output);
+		return false;
+	} else if (check_hash(2)) {
+		fs_set_blk_dev("mmc", "0:1", FS_TYPE_EXT);
+		printf("hash for second backup was correct\n");
+		write_output(locations[4], output);
+		return false;
+	}
+
+	printf("none of the hashes were correct. storing tmr result at 0xa0000000\n");
+
+	majority_wd(locations[0], locations[2], locations[4], locations[6], filesize);
+	write_output(locations[6], output);
+	return false;
+}
\ No newline at end of file
diff --git a/include/autoboot.h b/include/autoboot.h
index c175f91c5a..2fb8d08c81 100644
--- a/include/autoboot.h
+++ b/include/autoboot.h
@@ -24,6 +24,8 @@
  */
 const char *bootdelay_process(void);
 
+int abortboot(int bootdelay);
+
 /**
  * autoboot_command() - run the autoboot command
  *
@@ -39,6 +41,11 @@ static inline const char *bootdelay_process(void)
 	return NULL;
 }
 
+static inline int abortboot(int bootdelay)
+{
+	return 0;
+}
+
 static inline void autoboot_command(const char *s)
 {
 }
diff --git a/include/configs/p2771-0000.h b/include/configs/p2771-0000.h
index 1c8981b16f..ee863a557f 100644
--- a/include/configs/p2771-0000.h
+++ b/include/configs/p2771-0000.h
@@ -33,6 +33,10 @@
 #define CONFIG_PCI_PNP
 #define CONFIG_CMD_PCI
 
+/* Custom Commands */
+#define CONFIG_CMD_TMR
+#define CONFIG_CMD_MD5SUM
+
 #define BOARD_EXTRA_ENV_SETTINGS \
 	"calculated_vars=kernel_addr_r fdt_addr_r scriptaddr pxefile_addr_r " \
 		"ramdisk_addr_r\0" \
