diff --git a/README b/README
index 26d5ad273e..15542b816d 100644
--- a/README
+++ b/README
@@ -5,6 +5,15 @@
 # SPDX-License-Identifier:	GPL-2.0+
 #
 
+TMR Instructions:
+=================
+
+The TMR code is written in common/tmr.c and implemented in common/main.c (n main_loop()).
+
+Before flashing, some modifications must be made on the TX2i filesystem. Make 3 copies of the boot image (stored as /boot/Image, /boot/Image1, /boot/Image2), and store an md5 hash for each (/boot/hash, /boot/hash1, /boot/hash2). The filesize of the image is hard-coded into the TMR code (0x34048008 bytes, in hex), and this should be changed on common/tmr.c:68 if using an image of a different size.
+
+To flash the kernel, follow the "U-Boot Customization" instructions in the L4T docs, particularly the "Flashing U-Boot Only" section.
+
 Summary:
 ========
 
diff --git a/cmd/md5sum.c b/cmd/md5sum.c
index 23bb81e88c..e653b80deb 100644
--- a/cmd/md5sum.c
+++ b/cmd/md5sum.c
@@ -13,6 +13,7 @@
 #include <mapmem.h>
 #include <u-boot/md5.h>
 #include <asm/io.h>
+#include "../lib/md5.c"
 
 /*
  * Store the resulting sum to an address or variable
diff --git a/common/main.c b/common/main.c
index 2116a9e0a2..1320c5bc39 100644
--- a/common/main.c
+++ b/common/main.c
@@ -11,7 +11,9 @@
 #include <autoboot.h>
 #include <cli.h>
 #include <console.h>
+#include <malloc.h>
 #include <version.h>
+#include <../common/tmr.c>
 
 DECLARE_GLOBAL_DATA_PTR;
 
@@ -63,6 +65,36 @@ void main_loop(void)
 	if (cli_process_fdt(&s))
 		cli_secure_boot_cmd(s);
 
+	char *tmr_names[6];
+	printf("Reading filenames from info file\n");
+	fs_set_blk_dev("mmc", "0:1", FS_TYPE_EXT);
+	loff_t actread;
+	fs_read("info", 0x84000000, 0, 600, &actread);
+	printf("Read %lld of 360 bytes\n", actread);
+	char *all_names = (char *)map_sysmem(0x84000000, 600);
+
+	for (int i = 0; i < 6; i ++) {
+		tmr_names[i] = (char *)malloc(100);
+		memcpy(tmr_names[i], all_names+100*i, 100);
+	}
+
+	for(int i = 0; i < 3; i ++){
+		char file1[110] = "/boot/";
+		char file2[110] = "/boot1/";
+		char file3[110] = "/boot2/";
+		char hash[110] = "/boothash/";
+		strcat(file1, tmr_names[2*i]);
+		strcat(file2, tmr_names[2*i]);
+		strcat(file3, tmr_names[2*i]);
+		strcat(hash, tmr_names[2*i]);
+		char * const tmr_files[] = {file1, hash, file2, hash, file3, hash};
+		loff_t tmr_size = (loff_t) simple_strtoul(tmr_names[2*i+1], NULL, 10);
+		printf("Redundancy for %s, %s, %s, %s with size %lld\n", file1, file2, file3, hash, tmr_size);
+		tmr(tmr_files, tmr_size); 
+	}
+
+	unmap_sysmem((const void *)all_names);
+
 	autoboot_command(s);
 
 	cli_loop();
diff --git a/common/tmr.c b/common/tmr.c
new file mode 100644
index 0000000000..5ae5bec3e2
--- /dev/null
+++ b/common/tmr.c
@@ -0,0 +1,118 @@
+#include <common.h>
+#include <console.h>
+#include <bootretry.h>
+#include <cli.h>
+#include <command.h>
+#include <console.h>
+#include <mapmem.h>
+#include <watchdog.h>
+#include <fs.h>
+#include <u-boot/md5.h>
+
+loff_t filesize;
+ulong locations[7] = {0x85000000,0x89000000,0x90000000,0x94000000,0x95000000,0x99000000,0xa0000000};
+
+static void load_files_with_hashes(char * const files[]) {
+	for(ulong i = 0; i < 6; i ++) {
+		fs_set_blk_dev("mmc", "0:1", FS_TYPE_EXT);
+		loff_t actread;
+		if(i % 2) {
+			fs_read(files[i], locations[i], 0, 32, &actread);
+			printf("Read %lld of 32 bytes from %s\n", actread, files[i]);
+		} else {
+			fs_read(files[i], locations[i], 0, filesize, &actread);
+			printf("Read %lld of %lld bytes from %s\n", actread, filesize, files[i]);
+		}
+	}
+}
+
+int check_hash(int file) {
+	unsigned char calculated_sum[16], tmp[2];
+	
+	void *buf = map_sysmem(locations[file*2], filesize);
+	md5_wd(buf, filesize, calculated_sum, 64 << 10);
+	unmap_sysmem(buf);
+
+	buf = map_sysmem(locations[file*2+1], 32);
+
+	for (int i = 0; i < 16; i++) {
+		memcpy(tmp, (u8 *)buf + 2*i, 2);
+		if (simple_strtoul(tmp, NULL, 16) != calculated_sum[i]) {
+			unmap_sysmem(buf);
+			return 0;
+		}
+	}
+
+	unmap_sysmem(buf);
+	return 1;
+}
+
+static int majority_wd(ulong addr1, ulong addr2, ulong addr3, ulong dest, ulong bytes) {
+
+	ulong	nread;
+	void *buf1, *buf2, *buf3, *buf4;
+
+	ulong word1, word2, word3, word4;
+
+	buf1 = map_sysmem(addr1, bytes);
+	buf2 = map_sysmem(addr2, bytes);
+	buf3 = map_sysmem(addr3, bytes);
+	buf4 = map_sysmem(dest, bytes);
+
+	for (nread = 0; nread < bytes; nread ++) {
+
+		word1 = *(u8 *)buf1;
+		word2 = *(u8 *)buf2;
+		word3 = *(u8 *)buf3;
+
+		word4 = (word1 & word2) | (word2 & word3) | (word3 & word1); //majority voting gate
+
+		*(u8 *)buf4 = word4;
+
+		buf1 += 1;
+		buf2 += 1;
+		buf3 += 1;
+		buf4 += 1;
+
+		/* reset watchdog from time to time */
+		if ((nread % (64 << 10)) == 0)
+			WATCHDOG_RESET();
+
+	}
+
+	unmap_sysmem(buf1);
+	unmap_sysmem(buf2);
+	unmap_sysmem(buf3);
+	unmap_sysmem(buf4);
+
+	return 0;
+
+}
+
+static void tmr(char * const files[], loff_t size) {
+	filesize = size;
+	load_files_with_hashes(files);
+	loff_t actwrite;
+	printf("loaded files with hashes\n");
+	if (check_hash(0)) {
+		printf("hash for original file was correct\n");
+		return;
+	} else if (check_hash(1)) {
+		fs_set_blk_dev("mmc", "0:1", FS_TYPE_EXT);
+		printf("hash for first backup was correct\n");
+		fs_write(files[0], locations[2], 0, filesize, &actwrite);
+		return;
+	} else if (check_hash(2)) {
+		fs_set_blk_dev("mmc", "0:1", FS_TYPE_EXT);
+		printf("hash for second backup was correct\n");
+		fs_write(files[0], locations[4], 0, filesize, &actwrite);
+		return;
+	}
+
+	printf("none of the hashes were correct. storing tmr result at 0xa0000000\n");
+
+	majority_wd(locations[0], locations[2], locations[4], locations[6], filesize);
+	fs_set_blk_dev("mmc", "0:1", FS_TYPE_EXT);
+	fs_write(files[0], locations[6], 0, filesize, &actwrite);
+	printf("Wrote tmr result with size %lld of %lld back to %s\n", actwrite, filesize, files[0]);
+}
\ No newline at end of file
diff --git a/fs/ext4/ext4_journal.c b/fs/ext4/ext4_journal.c
index b40916b421..05908b9448 100644
--- a/fs/ext4/ext4_journal.c
+++ b/fs/ext4/ext4_journal.c
@@ -409,6 +409,9 @@ int ext4fs_check_journal_state(int recovery_flag)
 	char *temp_buff1 = NULL;
 	struct ext_filesystem *fs = get_fs();
 
+	if (le32_to_cpu(fs->sb->feature_ro_compat) & 0x0400)
+		return 0;
+
 	temp_buff = zalloc(fs->blksz);
 	if (!temp_buff)
 		return -ENOMEM;
diff --git a/include/configs/p2771-0000.h b/include/configs/p2771-0000.h
index 1c8981b16f..ee863a557f 100644
--- a/include/configs/p2771-0000.h
+++ b/include/configs/p2771-0000.h
@@ -33,6 +33,10 @@
 #define CONFIG_PCI_PNP
 #define CONFIG_CMD_PCI
 
+/* Custom Commands */
+#define CONFIG_CMD_TMR
+#define CONFIG_CMD_MD5SUM
+
 #define BOARD_EXTRA_ENV_SETTINGS \
 	"calculated_vars=kernel_addr_r fdt_addr_r scriptaddr pxefile_addr_r " \
 		"ramdisk_addr_r\0" \
