diff --git a/README b/README
index 26d5ad273e..15542b816d 100644
--- a/README
+++ b/README
@@ -5,6 +5,15 @@
 # SPDX-License-Identifier:	GPL-2.0+
 #
 
+TMR Instructions:
+=================
+
+The TMR code is written in common/tmr.c and implemented in common/main.c (n main_loop()).
+
+Before flashing, some modifications must be made on the TX2i filesystem. Make 3 copies of the boot image (stored as /boot/Image, /boot/Image1, /boot/Image2), and store an md5 hash for each (/boot/hash, /boot/hash1, /boot/hash2). The filesize of the image is hard-coded into the TMR code (0x34048008 bytes, in hex), and this should be changed on common/tmr.c:68 if using an image of a different size.
+
+To flash the kernel, follow the "U-Boot Customization" instructions in the L4T docs, particularly the "Flashing U-Boot Only" section.
+
 Summary:
 ========
 
diff --git a/cmd/md5sum.c b/cmd/md5sum.c
index 23bb81e88c..e653b80deb 100644
--- a/cmd/md5sum.c
+++ b/cmd/md5sum.c
@@ -13,6 +13,7 @@
 #include <mapmem.h>
 #include <u-boot/md5.h>
 #include <asm/io.h>
+#include "../lib/md5.c"
 
 /*
  * Store the resulting sum to an address or variable
diff --git a/common/autoboot.c b/common/autoboot.c
index c52bad84a4..1c61866935 100644
--- a/common/autoboot.c
+++ b/common/autoboot.c
@@ -255,7 +255,7 @@ static int __abortboot(int bootdelay)
 }
 # endif	/* CONFIG_AUTOBOOT_KEYED */
 
-static int abortboot(int bootdelay)
+int abortboot(int bootdelay)
 {
 	int abort = 0;
 
diff --git a/common/main.c b/common/main.c
index 2116a9e0a2..0e5001074c 100644
--- a/common/main.c
+++ b/common/main.c
@@ -11,7 +11,10 @@
 #include <autoboot.h>
 #include <cli.h>
 #include <console.h>
+#include <malloc.h>
 #include <version.h>
+#include <../common/tmr.c>
+#include <command.h>
 
 DECLARE_GLOBAL_DATA_PTR;
 
@@ -63,6 +66,89 @@ void main_loop(void)
 	if (cli_process_fdt(&s))
 		cli_secure_boot_cmd(s);
 
+	// error: no file system --> Assume BLOB
+	ulong file_offset[8] = {0, 1, 2, 90002, 90003, 92003, 92004, 98004};
+	ulong part_size = 4096000000 / 512;
+	ulong part_offset[3] = {4104, 4104+part_size, 4104+(2*part_size)};
+	ulong outputs[4];
+	outputs[0] = 0xa5000000; // in u-boot memory
+	outputs[1] = outputs[0] + 1 * 512;
+	outputs[2] = outputs[1] + 90000 * 512;
+	outputs[3] = outputs[2] + 2000 * 512;
+	ulong sizes[4];
+	sizes[0] = 60; //info file
+	char *safe = "s=----";
+
+	printf("TMRing info files\n");
+	if(
+		tmr_blob(
+			part_offset[0] + file_offset[0],
+			part_offset[0] + file_offset[1],
+			part_offset[1] + file_offset[0],
+			part_offset[1] + file_offset[1],
+			part_offset[2] + file_offset[0],
+			part_offset[2] + file_offset[1],
+			sizes[0], outputs[0])
+	) {
+		safe[2] = 'x';
+	}
+	
+	printf("Reading info for filesizes\n");
+	char tmp[15];
+	char *info = (char *)map_sysmem(locations[0], 45);
+	for (int i = 0; i < 3; i ++) {
+		memcpy(tmp, info + 15 * i, 15);
+		sizes[i+1] = simple_strtoul(tmp, NULL, 10);
+	}
+	unmap_sysmem((const void*) info);
+
+	for (int i = 1; i < 4; i ++) {
+		printf("TMRing file #%d of size %lu\n", i, sizes[i]);
+		if(
+			!tmr_blob(
+				part_offset[0] + file_offset[2*i],
+				part_offset[0] + file_offset[2*i+1],
+				part_offset[1] + file_offset[2*i],
+				part_offset[1] + file_offset[2*i+1],
+				part_offset[2] + file_offset[2*i],
+				part_offset[2] + file_offset[2*i+1],
+				sizes[i], outputs[i])
+		) {
+			// pass info to kernel
+			safe[i+2] = 'x';
+		}
+	}
+
+	// TODO: See if we can find a way to make use of bootargs
+	//setenv("bootargs", safe);
+	char bootargs[CONFIG_SYS_CBSIZE];
+	cli_simple_process_macros("${cbootargs} root=/dev/ram0 rw rootwait ${bootargs}", bootargs);
+	setenv("bootargs", bootargs);
+
+	if(!abortboot(5)) {
+		char initrd_loc[15*2] = "";
+		sprintf(initrd_loc, "%x:%x", outputs[3], sizes[3]);
+		char image_loc[15] = "";
+		sprintf(image_loc, "%x", outputs[1]);
+		char dtb_loc[15] = "";
+		sprintf(dtb_loc, "%x", outputs[2]);
+		char *argv[4] = {
+						"booti",
+						image_loc,
+						initrd_loc,
+						dtb_loc
+						};
+		cmd_tbl_t *bcmd = find_cmd("booti");
+		do_booti(bcmd, 0, 4, argv);
+	} else {
+		cli_loop();
+		panic("No CLI available");
+	}
+
+	
+
+	
+
 	autoboot_command(s);
 
 	cli_loop();
diff --git a/common/tmr.c b/common/tmr.c
new file mode 100644
index 0000000000..a9e3629c0f
--- /dev/null
+++ b/common/tmr.c
@@ -0,0 +1,172 @@
+#include <common.h>
+#include <console.h>
+#include <bootretry.h>
+#include <cli.h>
+#include <command.h>
+#include <console.h>
+#include <mapmem.h>
+#include <watchdog.h>
+#include <fs.h>
+#include <u-boot/md5.h>
+#include <blk.h>
+#include <mmc.h>
+
+loff_t filesize;
+ulong locations[7] = {0x85000000,0x89000000,0x90000000,0x94000000,0x95000000,0x99000000,0xa0000000};
+
+
+static void load_blobs_with_hashes(
+	ulong file1, ulong hash1, 
+	ulong file2, ulong hash2,
+	ulong file3, ulong hash3
+)
+{
+	struct mmc *mmc;
+	printf("Finding mmc device 0\n");
+	mmc = find_mmc_device(0);
+	mmc->has_init = 0;
+	printf("Initializing mmc device 0\n");
+	mmc_init(mmc);
+
+	u32 cnt = filesize / 512 + 1;
+
+	void *addr = (void *)locations[0];
+	printf("Reading from mmc\n");
+	ulong n = blk_dread(mmc_get_blk_desc(mmc), file1, cnt, addr);
+	printf("Flushing cache\n");
+	flush_cache((ulong)addr, cnt * 512);
+	printf("%lu blocks read: %s\n", n, (n == cnt) ? "OK" : "ERROR");
+
+	addr = (void *)locations[1];
+	n = blk_dread(mmc_get_blk_desc(mmc), hash1, 1, addr);
+	flush_cache((ulong)addr, 512);
+	printf("%lu blocks read: %s\n", n, (n == 1) ? "OK" : "ERROR");
+
+	addr = (void *)locations[2];
+	n = blk_dread(mmc_get_blk_desc(mmc), file2, cnt, addr);
+	flush_cache((ulong)addr, cnt * 512);
+	printf("%lu blocks read: %s\n", n, (n == cnt) ? "OK" : "ERROR");
+
+	addr = (void *)locations[3];
+	n = blk_dread(mmc_get_blk_desc(mmc), hash2, 1, addr);
+	flush_cache((ulong)addr, 512);
+	printf("%lu blocks read: %s\n", n, (n == 1) ? "OK" : "ERROR");
+
+	addr = (void *)locations[4];
+	n = blk_dread(mmc_get_blk_desc(mmc), file3, cnt, addr);
+	flush_cache((ulong)addr, cnt * 512);
+	printf("%lu blocks read: %s\n", n, (n == cnt) ? "OK" : "ERROR");
+
+	addr = (void *)locations[5];
+	n = blk_dread(mmc_get_blk_desc(mmc), hash3, 1, addr);
+	flush_cache((ulong)addr, 512);
+	printf("%lu blocks read: %s\n", n, (n == 1) ? "OK" : "ERROR");
+}
+
+int check_hash(int file) {
+	unsigned char calculated_sum[16], tmp[2];
+	
+	void *buf = map_sysmem(locations[file*2], filesize);
+	md5_wd(buf, filesize, calculated_sum, 64 << 10);
+	unmap_sysmem(buf);
+
+	buf = map_sysmem(locations[file*2+1], 32);
+
+	for (int i = 0; i < 16; i++) {
+		memcpy(tmp, (u8 *)buf + 2*i, 2);
+		if(simple_strtoul(tmp, NULL, 16) != calculated_sum[i]) {
+			unmap_sysmem(buf);
+			return 0;
+		}
+	}
+
+	unmap_sysmem(buf);
+	return 1;
+}
+
+static int majority_wd(ulong addr1, ulong addr2, ulong addr3, ulong dest, ulong bytes) {
+
+	ulong	nread;
+	void *buf1, *buf2, *buf3, *buf4;
+
+	ulong word1, word2, word3, word4;
+
+	buf1 = map_sysmem(addr1, bytes);
+	buf2 = map_sysmem(addr2, bytes);
+	buf3 = map_sysmem(addr3, bytes);
+	buf4 = map_sysmem(dest, bytes);
+
+	for (nread = 0; nread < bytes; nread ++) {
+
+		word1 = *(u8 *)buf1;
+		word2 = *(u8 *)buf2;
+		word3 = *(u8 *)buf3;
+
+		word4 = (word1 & word2) | (word2 & word3) | (word3 & word1); //majority voting gate
+
+		*(u8 *)buf4 = word4;
+
+		buf1 += 1;
+		buf2 += 1;
+		buf3 += 1;
+		buf4 += 1;
+
+		/* reset watchdog from time to time */
+		if ((nread % (64 << 10)) == 0)
+			WATCHDOG_RESET();
+
+	}
+
+	unmap_sysmem(buf1);
+	unmap_sysmem(buf2);
+	unmap_sysmem(buf3);
+	unmap_sysmem(buf4);
+
+	return 0;
+
+}
+
+
+static void write_output(ulong input, ulong output) {
+	memcpy((void *)output, (void *)input, filesize);
+}
+
+static bool tmr_blob(
+	ulong file1, ulong hash1, 
+	ulong file2, ulong hash2,
+	ulong file3, ulong hash3,
+	ulong bytes, ulong output)
+{
+	filesize = bytes;
+	//locations[0] = 0x85000000; // base location to start at for tmr, in u-boot memory
+	locations[1] = locations[0] + 90000 * 512;
+	locations[2] = locations[1] + 1024;
+	locations[3] = locations[2] + 90000 * 512;
+	locations[4] = locations[3] + 1024;
+	locations[5] = locations[4] + 90000 * 512;
+	locations[6] = locations[5] + 1024;
+	
+	load_blobs_with_hashes(file1, hash1, file2, hash2, file3, hash3);
+	printf("loaded files with hashes\n");
+	if (check_hash(0)) {
+		printf("hash for original file was correct\n");
+		write_output(locations[0], output);
+		return true;
+	} else if (check_hash(1)) {
+		fs_set_blk_dev("mmc", "0:1", FS_TYPE_EXT);
+		printf("hash for first backup was correct\n");
+		write_output(locations[2], output);
+		return false;
+	} else if (check_hash(2)) {
+		fs_set_blk_dev("mmc", "0:1", FS_TYPE_EXT);
+		printf("hash for second backup was correct\n");
+		write_output(locations[4], output);
+		return false;
+	}
+
+	printf("none of the hashes were correct. storing tmr result at 0xa0000000\n");
+
+	majority_wd(locations[0], locations[2], locations[4], locations[6], filesize);
+	write_output(locations[6], output);
+	return false;
+}
\ No newline at end of file
diff --git a/include/autoboot.h b/include/autoboot.h
index c175f91c5a..2fb8d08c81 100644
--- a/include/autoboot.h
+++ b/include/autoboot.h
@@ -24,6 +24,8 @@
  */
 const char *bootdelay_process(void);
 
+int abortboot(int bootdelay);
+
 /**
  * autoboot_command() - run the autoboot command
  *
@@ -39,6 +41,11 @@ static inline const char *bootdelay_process(void)
 	return NULL;
 }
 
+static inline int abortboot(int bootdelay)
+{
+	return 0;
+}
+
 static inline void autoboot_command(const char *s)
 {
 }
diff --git a/include/configs/p2771-0000.h b/include/configs/p2771-0000.h
index 1c8981b16f..ee863a557f 100644
--- a/include/configs/p2771-0000.h
+++ b/include/configs/p2771-0000.h
@@ -33,6 +33,10 @@
 #define CONFIG_PCI_PNP
 #define CONFIG_CMD_PCI
 
+/* Custom Commands */
+#define CONFIG_CMD_TMR
+#define CONFIG_CMD_MD5SUM
+
 #define BOARD_EXTRA_ENV_SETTINGS \
 	"calculated_vars=kernel_addr_r fdt_addr_r scriptaddr pxefile_addr_r " \
 		"ramdisk_addr_r\0" \
