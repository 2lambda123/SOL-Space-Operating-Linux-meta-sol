diff --git a/README b/README
index 26d5ad273e..15542b816d 100644
--- a/README
+++ b/README
@@ -5,6 +5,15 @@
 # SPDX-License-Identifier:	GPL-2.0+
 #
 
+TMR Instructions:
+=================
+
+The TMR code is written in common/tmr.c and implemented in common/main.c (n main_loop()).
+
+Before flashing, some modifications must be made on the TX2i filesystem. Make 3 copies of the boot image (stored as /boot/Image, /boot/Image1, /boot/Image2), and store an md5 hash for each (/boot/hash, /boot/hash1, /boot/hash2). The filesize of the image is hard-coded into the TMR code (0x34048008 bytes, in hex), and this should be changed on common/tmr.c:68 if using an image of a different size.
+
+To flash the kernel, follow the "U-Boot Customization" instructions in the L4T docs, particularly the "Flashing U-Boot Only" section.
+
 Summary:
 ========
 
diff --git a/cmd/md5sum.c b/cmd/md5sum.c
index 23bb81e88c..e653b80deb 100644
--- a/cmd/md5sum.c
+++ b/cmd/md5sum.c
@@ -13,6 +13,7 @@
 #include <mapmem.h>
 #include <u-boot/md5.h>
 #include <asm/io.h>
+#include "../lib/md5.c"
 
 /*
  * Store the resulting sum to an address or variable
diff --git a/common/autoboot.c b/common/autoboot.c
index c52bad84a4..1c61866935 100644
--- a/common/autoboot.c
+++ b/common/autoboot.c
@@ -255,7 +255,7 @@ static int __abortboot(int bootdelay)
 }
 # endif	/* CONFIG_AUTOBOOT_KEYED */
 
-static int abortboot(int bootdelay)
+int abortboot(int bootdelay)
 {
 	int abort = 0;
 
diff --git a/common/main.c b/common/main.c
index 2116a9e0a2..f4ce089633 100644
--- a/common/main.c
+++ b/common/main.c
@@ -11,7 +11,10 @@
 #include <autoboot.h>
 #include <cli.h>
 #include <console.h>
+#include <malloc.h>
 #include <version.h>
+#include <../common/tmr.c>
+#include <command.h>
 
 DECLARE_GLOBAL_DATA_PTR;
 
@@ -62,9 +65,87 @@ void main_loop(void)
 	s = bootdelay_process();
 	if (cli_process_fdt(&s))
 		cli_secure_boot_cmd(s);
+    printf("meta-sol version 2.0\n"); // kinda arbitrary
+    fs_set_blk_dev("mmc", "0:1", FS_TYPE_EXT);
+
+    ulong file_offset[8] = {YOCTO_INFO_FILE_OFFSET, YOCTO_INFO_HASH_OFFSET,
+                            YOCTO_IMAGE_FILE_OFFSET, YOCTO_IMAGE_HASH_OFFSET,
+                            YOCTO_DTB_FILE_OFFSET, YOCTO_DTB_HASH_OFFSET,
+                            YOCTO_INITRD_FILE_OFFSET, YOCTO_INITRD_HASH_OFFSET};
+    ulong part_size = YOCTO_ROOTFSPART_SIZE / YOCTO_BLOCK_SIZE;
+    ulong part_offset[3] = {YOCTO_PARTITION_OFFSET,
+                            YOCTO_PARTITION_OFFSET + part_size,
+                            YOCTO_PARTITION_OFFSET + (2 * part_size)};
+    ulong outputs[4];
+    outputs[0] = 0xa5000000; // in u-boot memory
+    outputs[1] = outputs[0] + YOCTO_INFO_FILE_BLOCKS * YOCTO_BLOCK_SIZE;
+    outputs[2] = outputs[1] + YOCTO_IMAGE_FILE_BLOCKS * YOCTO_BLOCK_SIZE;
+    outputs[3] = outputs[2] + YOCTO_DTB_FILE_BLOCKS * YOCTO_BLOCK_SIZE;
+    ulong sizes[4];
+    sizes[0] = YOCTO_INFO_BYTES * 4; //info file, 4 filesizes
+    char *safe = "s=----";
+
+    printf("TMRing info files\n");
+    if(
+        tmr_blob(
+            part_offset[0] + file_offset[0],
+            part_offset[0] + file_offset[1],
+            part_offset[1] + file_offset[0],
+            part_offset[1] + file_offset[1],
+            part_offset[2] + file_offset[0],
+            part_offset[2] + file_offset[1],
+            sizes[0], outputs[0])
+    ) {
+        safe[2] = 'x';
+    }
+    
+    printf("Reading info for filesizes\n");
+    char tmp[YOCTO_INFO_BYTES];
+    char *info = (char *)map_sysmem(outputs[0], YOCTO_INFO_BYTES*3);
+    for (int i = 0; i < 3; i ++) {
+        memcpy(tmp, info + YOCTO_INFO_BYTES * i, YOCTO_INFO_BYTES);
+        sizes[i+1] = simple_strtoul(tmp, NULL, 10);
+    }
+    unmap_sysmem((const void*) info);
+
+    for (int i = 1; i < 4; i ++) {
+        printf("TMRing file #%d of size %lu\n", i, sizes[i]);
+        if(
+            !tmr_blob(
+                part_offset[0] + file_offset[2*i],
+                part_offset[0] + file_offset[2*i+1],
+                part_offset[1] + file_offset[2*i],
+                part_offset[1] + file_offset[2*i+1],
+                part_offset[2] + file_offset[2*i],
+                part_offset[2] + file_offset[2*i+1],
+                sizes[i], outputs[i])
+        ) {
+            // pass info to kernel
+            safe[i+2] = 'x';
+        }
+    }
+
+    // TODO: See if we can find a way to make use of bootargs
+    //setenv("bootargs", safe);
+    char bootargs[CONFIG_SYS_CBSIZE];
+    cli_simple_process_macros("${cbootargs} root=/dev/ram0 rw rootwait ${bootargs}", bootargs);
+    setenv("bootargs", bootargs);
+
+    if(!abortboot(5)) {
+        char initrd_loc[YOCTO_INFO_BYTES*2] = "";
+        sprintf(initrd_loc, "%x:%x", outputs[3], sizes[3]);
+		char image_loc[YOCTO_INFO_BYTES] = "";
+        sprintf(image_loc, "%x", outputs[1]);
+        char dtb_loc[YOCTO_INFO_BYTES] = "";
+        sprintf(dtb_loc, "%x", outputs[2]);
+        char *argv[4] = {"booti", image_loc,
+                         initrd_loc,
+                         dtb_loc};
+        cmd_tbl_t *bcmd = find_cmd("booti");
+        do_booti(bcmd, 0, 4, argv);
+    } else {
+        cli_loop();
+        panic("No CLI available");
+    }
 
-	autoboot_command(s);
-
-	cli_loop();
-	panic("No CLI available");
 }
diff --git a/common/tmr.c b/common/tmr.c
new file mode 100644
index 0000000000..c75b3241a5
--- /dev/null
+++ b/common/tmr.c
@@ -0,0 +1,162 @@
+#include <common.h>
+#include <console.h>
+#include <bootretry.h>
+#include <cli.h>
+#include <command.h>
+#include <console.h>
+#include <mapmem.h>
+#include <watchdog.h>
+#include <fs.h>
+#include <u-boot/md5.h>
+#include <blk.h>
+#include <mmc.h>
+
+static void load_blobs_with_hashes(
+	ulong file1, ulong hash1, 
+	ulong file2, ulong hash2,
+	ulong file3, ulong hash3,
+	loff_t filesize, ulong *locations
+)
+{
+	struct mmc *mmc;
+	printf("Finding mmc device 0\n");
+	mmc = find_mmc_device(0);
+	mmc->has_init = 0;
+	printf("Initializing mmc device 0\n");
+	mmc_init(mmc);
+
+	u32 cnt = filesize / YOCTO_BLOCK_SIZE + 1;
+
+	void *addr = (void *)locations[0];
+	printf("Reading from mmc\n");
+	ulong n = blk_dread(mmc_get_blk_desc(mmc), file1, cnt, addr);
+	printf("%lu blocks read: %s\n", n, (n == cnt) ? "OK" : "ERROR");
+
+	addr = (void *)locations[1];
+	n = blk_dread(mmc_get_blk_desc(mmc), hash1, 1, addr);
+	printf("%lu blocks read: %s\n", n, (n == 1) ? "OK" : "ERROR");
+
+	addr = (void *)locations[2];
+	n = blk_dread(mmc_get_blk_desc(mmc), file2, cnt, addr);
+	printf("%lu blocks read: %s\n", n, (n == cnt) ? "OK" : "ERROR");
+
+	addr = (void *)locations[3];
+	n = blk_dread(mmc_get_blk_desc(mmc), hash2, 1, addr);
+	printf("%lu blocks read: %s\n", n, (n == 1) ? "OK" : "ERROR");
+
+	addr = (void *)locations[4];
+	n = blk_dread(mmc_get_blk_desc(mmc), file3, cnt, addr);
+	printf("%lu blocks read: %s\n", n, (n == cnt) ? "OK" : "ERROR");
+
+	addr = (void *)locations[5];
+	n = blk_dread(mmc_get_blk_desc(mmc), hash3, 1, addr);
+	printf("%lu blocks read: %s\n", n, (n == 1) ? "OK" : "ERROR");
+}
+
+int check_hash(int file, loff_t filesize, ulong *locations) {
+	unsigned char calculated_sum[16], tmp[2];
+	
+	void *buf = map_sysmem(locations[file*2], filesize);
+	md5_wd(buf, filesize, calculated_sum, 64 << 10);
+	unmap_sysmem(buf);
+
+	buf = map_sysmem(locations[file*2+1], 32);
+
+	for (int i = 0; i < 16; i++) {
+		memcpy(tmp, (u8 *)buf + 2*i, 2);
+		if(simple_strtoul(tmp, NULL, 16) != calculated_sum[i]) {
+			unmap_sysmem(buf);
+			return 0;
+		}
+	}
+
+	unmap_sysmem(buf);
+	return 1;
+}
+
+static int majority_wd(ulong addr1, ulong addr2, ulong addr3, ulong dest, ulong bytes) {
+
+	ulong	nread;
+	void *buf1, *buf2, *buf3, *buf4;
+
+	ulong word1, word2, word3, word4;
+
+	buf1 = map_sysmem(addr1, bytes);
+	buf2 = map_sysmem(addr2, bytes);
+	buf3 = map_sysmem(addr3, bytes);
+	buf4 = map_sysmem(dest, bytes);
+
+	for (nread = 0; nread < bytes; nread ++) {
+
+		word1 = *(u8 *)buf1;
+		word2 = *(u8 *)buf2;
+		word3 = *(u8 *)buf3;
+
+		word4 = (word1 & word2) | (word2 & word3) | (word3 & word1); //majority voting gate
+
+		*(u8 *)buf4 = word4;
+
+		buf1 += 1;
+		buf2 += 1;
+		buf3 += 1;
+		buf4 += 1;
+
+		/* reset watchdog from time to time */
+		if ((nread % (64 << 10)) == 0)
+			WATCHDOG_RESET();
+
+	}
+
+	unmap_sysmem(buf1);
+	unmap_sysmem(buf2);
+	unmap_sysmem(buf3);
+	unmap_sysmem(buf4);
+
+	return 0;
+
+}
+
+static void write_output(ulong input, ulong output, loff_t filesize) {
+	memcpy((void *)output, (void *)input, filesize);
+}
+
+static bool tmr_blob(
+	ulong file1, ulong hash1, 
+	ulong file2, ulong hash2,
+	ulong file3, ulong hash3,
+	ulong bytes, ulong output)
+{
+	loff_t filesize = bytes;
+	const ulong first_copy_loc = 0x85000000; // base location to start at for tmr, in u-boot memory
+	const ulong first_hash_loc = first_copy_loc + YOCTO_MAX_FILE_BLOCKS * YOCTO_BLOCK_SIZE;
+	const ulong second_copy_loc = first_hash_loc + 1024;
+	const ulong second_hash_loc = second_copy_loc + YOCTO_MAX_FILE_BLOCKS * YOCTO_BLOCK_SIZE;
+	const ulong third_copy_loc = second_hash_loc + 1024;
+	const ulong third_hash_loc = third_copy_loc + YOCTO_MAX_FILE_BLOCKS * YOCTO_BLOCK_SIZE;
+	const ulong output_loc = third_hash_loc + 1024;
+	ulong locations[7] = {first_copy_loc, first_hash_loc, second_copy_loc, second_hash_loc, third_copy_loc, third_hash_loc, output_loc};
+	
+	load_blobs_with_hashes(file1, hash1, file2, hash2, file3, hash3, filesize, locations);
+	printf("loaded files with hashes\n");
+	if (check_hash(0, filesize, locations)) {
+		printf("hash for original file was correct\n");
+		write_output(locations[0], output, filesize);
+		return true;
+	} else if (check_hash(1, filesize, locations)) {
+		fs_set_blk_dev("mmc", "0:1", FS_TYPE_EXT);
+		printf("hash for first backup was correct\n");
+		write_output(locations[2], output, filesize);
+		return false;
+	} else if (check_hash(2, filesize, locations)) {
+		fs_set_blk_dev("mmc", "0:1", FS_TYPE_EXT);
+		printf("hash for second backup was correct\n");
+		write_output(locations[4], output, filesize);
+		return false;
+	}
+
+	printf("none of the hashes were correct. storing tmr result at 0xa0000000\n");
+
+	majority_wd(locations[0], locations[2], locations[4], locations[6], filesize);
+	write_output(locations[6], output, filesize);
+	return false;
+}
\ No newline at end of file
diff --git a/include/autoboot.h b/include/autoboot.h
index c175f91c5a..2fb8d08c81 100644
--- a/include/autoboot.h
+++ b/include/autoboot.h
@@ -24,6 +24,8 @@
  */
 const char *bootdelay_process(void);
 
+int abortboot(int bootdelay);
+
 /**
  * autoboot_command() - run the autoboot command
  *
@@ -39,6 +41,11 @@ static inline const char *bootdelay_process(void)
 	return NULL;
 }
 
+static inline int abortboot(int bootdelay)
+{
+	return 0;
+}
+
 static inline void autoboot_command(const char *s)
 {
 }
diff --git a/include/configs/p2771-0000.h b/include/configs/p2771-0000.h
index 1c8981b16f..ee863a557f 100644
--- a/include/configs/p2771-0000.h
+++ b/include/configs/p2771-0000.h
@@ -33,6 +33,10 @@
 #define CONFIG_PCI_PNP
 #define CONFIG_CMD_PCI
 
+/* Custom Commands */
+#define CONFIG_CMD_TMR
+#define CONFIG_CMD_MD5SUM
+
 #define BOARD_EXTRA_ENV_SETTINGS \
 	"calculated_vars=kernel_addr_r fdt_addr_r scriptaddr pxefile_addr_r " \
 		"ramdisk_addr_r\0" \
